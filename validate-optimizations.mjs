/**
 * Script de Valida√ß√£o das Otimiza√ß√µes (Modo Offline)
 * 
 * Valida se os arquivos e estruturas foram criados corretamente
 * sem necessidade de conex√£o com o banco de dados.
 */

import { readFileSync, existsSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Valida se os arquivos de migra√ß√£o foram criados
 */
function validateMigrationFiles() {
  console.log('üìÑ Validando arquivos de migra√ß√£o...\n');
  
  const files = [
    {
      path: 'supabase/migrations/20250131000004_optimize_match_hierarchical_documents.sql',
      name: 'Migra√ß√£o de Otimiza√ß√£o',
      requiredContent: [
        'match_hierarchical_documents_optimized',
        'hierarchical_search_cache',
        'search_performance_log',
        'contextual_scoring',
        'performance_metrics'
      ]
    },
    {
      path: 'supabase/migrations/20250131000003_optimize_composite_indexes.sql',
      name: '√çndices Compostos',
      requiredContent: [
        'idx_document_embeddings_vector_composite',
        'idx_document_embeddings_hierarchical',
        'idx_document_embeddings_altura_queries'
      ]
    }
  ];
  
  let allValid = true;
  
  for (const file of files) {
    const fullPath = join(__dirname, file.path);
    
    if (!existsSync(fullPath)) {
      console.log(`‚ùå ${file.name}: Arquivo n√£o encontrado - ${file.path}`);
      allValid = false;
      continue;
    }
    
    try {
      const content = readFileSync(fullPath, 'utf-8');
      
      let missingContent = [];
      for (const required of file.requiredContent) {
        if (!content.includes(required)) {
          missingContent.push(required);
        }
      }
      
      if (missingContent.length > 0) {
        console.log(`‚ö†Ô∏è  ${file.name}: Conte√∫do faltando - ${missingContent.join(', ')}`);
        allValid = false;
      } else {
        console.log(`‚úÖ ${file.name}: OK (${Math.round(content.length / 1024)}KB)`);
      }
      
    } catch (error) {
      console.log(`‚ùå ${file.name}: Erro ao ler arquivo - ${error.message}`);
      allValid = false;
    }
  }
  
  return allValid;
}

/**
 * Valida scripts de teste e aplica√ß√£o
 */
function validateScripts() {
  console.log('\nüß™ Validando scripts de teste e aplica√ß√£o...\n');
  
  const scripts = [
    {
      path: 'test-performance-optimizations.mjs',
      name: 'Script de Teste de Performance',
      requiredFunctions: [
        'testPerformanceComparison',
        'testBatchPerformance',
        'testPerformanceModes',
        'checkCacheStatistics'
      ]
    },
    {
      path: 'apply-performance-optimizations.mjs',
      name: 'Script de Aplica√ß√£o',
      requiredFunctions: [
        'applyOptimizationMigration',
        'verifyOptimizations',
        'testOptimizedFunction'
      ]
    }
  ];
  
  let allValid = true;
  
  for (const script of scripts) {
    const fullPath = join(__dirname, script.path);
    
    if (!existsSync(fullPath)) {
      console.log(`‚ùå ${script.name}: Arquivo n√£o encontrado`);
      allValid = false;
      continue;
    }
    
    try {
      const content = readFileSync(fullPath, 'utf-8');
      
      let missingFunctions = [];
      for (const func of script.requiredFunctions) {
        if (!content.includes(`function ${func}`) && !content.includes(`const ${func}`)) {
          missingFunctions.push(func);
        }
      }
      
      if (missingFunctions.length > 0) {
        console.log(`‚ö†Ô∏è  ${script.name}: Fun√ß√µes faltando - ${missingFunctions.join(', ')}`);
        allValid = false;
      } else {
        console.log(`‚úÖ ${script.name}: OK (${Math.round(content.length / 1024)}KB)`);
      }
      
    } catch (error) {
      console.log(`‚ùå ${script.name}: Erro ao ler - ${error.message}`);
      allValid = false;
    }
  }
  
  return allValid;
}

/**
 * Valida atualiza√ß√µes na fun√ß√£o enhanced-vector-search
 */
function validateEnhancedVectorSearch() {
  console.log('\nüîç Validando atualiza√ß√µes no enhanced-vector-search...\n');
  
  const filePath = join(__dirname, 'supabase/functions/enhanced-vector-search/index.ts');
  
  if (!existsSync(filePath)) {
    console.log('‚ùå Arquivo enhanced-vector-search/index.ts n√£o encontrado');
    return false;
  }
  
  try {
    const content = readFileSync(filePath, 'utf-8');
    
    const expectedUpdates = [
      {
        name: 'Chamada para fun√ß√£o otimizada',
        pattern: 'match_hierarchical_documents_optimized',
        found: content.includes('match_hierarchical_documents_optimized')
      },
      {
        name: 'Par√¢metros de performance',
        pattern: 'performance_mode',
        found: content.includes('performance_mode')
      },
      {
        name: 'Fallback para fun√ß√£o padr√£o',
        pattern: 'falling back to standard',
        found: content.includes('falling back') || content.includes('fallback')
      },
      {
        name: 'Logs de performance',
        pattern: 'performance metrics',
        found: content.includes('performance_metrics') || content.includes('Performance:')
      }
    ];
    
    let allUpdated = true;
    
    for (const update of expectedUpdates) {
      if (update.found) {
        console.log(`‚úÖ ${update.name}: Implementado`);
      } else {
        console.log(`‚ùå ${update.name}: N√£o encontrado`);
        allUpdated = false;
      }
    }
    
    return allUpdated;
    
  } catch (error) {
    console.log(`‚ùå Erro ao validar enhanced-vector-search: ${error.message}`);
    return false;
  }
}

/**
 * Analisa complexidade das otimiza√ß√µes
 */
function analyzeOptimizationComplexity() {
  console.log('\nüìä Analisando complexidade das otimiza√ß√µes...\n');
  
  try {
    const migrationPath = join(__dirname, 'supabase/migrations/20250131000004_optimize_match_hierarchical_documents.sql');
    const content = readFileSync(migrationPath, 'utf-8');
    
    const metrics = {
      totalLines: content.split('\n').length,
      functions: (content.match(/CREATE.*FUNCTION/gi) || []).length,
      tables: (content.match(/CREATE.*TABLE/gi) || []).length,
      indexes: (content.match(/CREATE.*INDEX/gi) || []).length,
      views: (content.match(/CREATE.*VIEW/gi) || []).length,
      ctes: (content.match(/WITH\s+\w+\s+AS/gi) || []).length,
      comments: (content.match(/--.*$/gm) || []).length
    };
    
    console.log('üìà M√©tricas da Migra√ß√£o:');
    console.log(`   üìÑ Total de linhas: ${metrics.totalLines}`);
    console.log(`   ‚öôÔ∏è  Fun√ß√µes criadas: ${metrics.functions}`);
    console.log(`   üìä Tabelas criadas: ${metrics.tables}`);
    console.log(`   üîç √çndices criados: ${metrics.indexes}`);
    console.log(`   üëÅÔ∏è  Views criadas: ${metrics.views}`);
    console.log(`   üèóÔ∏è  CTEs implementados: ${metrics.ctes}`);
    console.log(`   üí¨ Linhas de coment√°rio: ${metrics.comments}`);
    
    // An√°lise de complexidade
    const complexityScore = (
      metrics.functions * 10 +
      metrics.tables * 5 +
      metrics.indexes * 3 +
      metrics.views * 4 +
      metrics.ctes * 2
    );
    
    console.log(`\nüéØ Score de Complexidade: ${complexityScore}`);
    
    if (complexityScore > 100) {
      console.log('   üî• Otimiza√ß√£o AVAN√áADA - M√∫ltiplas t√©cnicas aplicadas');
    } else if (complexityScore > 50) {
      console.log('   ‚ö° Otimiza√ß√£o INTERMEDI√ÅRIA - Boas pr√°ticas aplicadas');
    } else {
      console.log('   üìà Otimiza√ß√£o B√ÅSICA - Melhorias incrementais');
    }
    
    return true;
    
  } catch (error) {
    console.log(`‚ùå Erro na an√°lise: ${error.message}`);
    return false;
  }
}

/**
 * Gera checklist de execu√ß√£o
 */
function generateExecutionChecklist() {
  console.log('\nüìã CHECKLIST DE EXECU√á√ÉO');
  console.log('========================\n');
  
  const steps = [
    {
      step: '1. Configurar Vari√°veis de Ambiente',
      commands: [
        'export SUPABASE_URL="https://seu-projeto.supabase.co"',
        'export SUPABASE_SERVICE_ROLE_KEY="sua-service-key"'
      ],
      description: 'Necess√°rio para conectar com o banco'
    },
    {
      step: '2. Aplicar Otimiza√ß√µes',
      commands: [
        'node apply-performance-optimizations.mjs'
      ],
      description: 'Aplica todas as migra√ß√µes e otimiza√ß√µes'
    },
    {
      step: '3. Executar Testes',
      commands: [
        'node test-performance-optimizations.mjs'
      ],
      description: 'Valida performance e funcionalidade'
    },
    {
      step: '4. Monitorar Performance',
      commands: [
        'SELECT * FROM hierarchical_search_performance;',
        'SELECT * FROM hierarchical_cache_status;'
      ],
      description: 'Acompanhar m√©tricas de performance'
    }
  ];
  
  for (const step of steps) {
    console.log(`‚úÖ ${step.step}`);
    console.log(`   üìù ${step.description}`);
    console.log('   üíª Comandos:');
    step.commands.forEach(cmd => {
      console.log(`      ${cmd}`);
    });
    console.log('');
  }
}

/**
 * Script principal
 */
function main() {
  console.log('üîç VALIDA√á√ÉO DAS OTIMIZA√á√ïES DE PERFORMANCE');
  console.log('=============================================\n');
  
  const results = {
    migrationFiles: false,
    scripts: false,
    enhancedVectorSearch: false,
    complexity: false
  };
  
  // Executar valida√ß√µes
  results.migrationFiles = validateMigrationFiles();
  results.scripts = validateScripts();
  results.enhancedVectorSearch = validateEnhancedVectorSearch();
  results.complexity = analyzeOptimizationComplexity();
  
  // Resumo final
  console.log('\n' + '='.repeat(50));
  console.log('üìã RESUMO DA VALIDA√á√ÉO');
  console.log('='.repeat(50) + '\n');
  
  const totalChecks = Object.keys(results).length;
  const passedChecks = Object.values(results).filter(Boolean).length;
  const successRate = (passedChecks / totalChecks) * 100;
  
  console.log(`üìä Valida√ß√µes passaram: ${passedChecks}/${totalChecks} (${successRate.toFixed(1)}%)\n`);
  
  Object.entries(results).forEach(([check, passed]) => {
    const status = passed ? '‚úÖ' : '‚ùå';
    const checkName = check.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
    console.log(`${status} ${checkName}`);
  });
  
  if (successRate === 100) {
    console.log('\nüéâ Todas as valida√ß√µes passaram!');
    console.log('‚ú® As otimiza√ß√µes est√£o prontas para aplica√ß√£o.');
  } else if (successRate >= 75) {
    console.log('\n‚ö†Ô∏è  Maioria das valida√ß√µes passou.');
    console.log('üîß Revise os itens com falha antes de aplicar.');
  } else {
    console.log('\n‚ùå V√°rias valida√ß√µes falharam.');
    console.log('üõ†Ô∏è  Corrija os problemas antes de prosseguir.');
  }
  
  // Gerar checklist independente do resultado
  generateExecutionChecklist();
  
  return successRate;
}

// Executar valida√ß√£o
if (import.meta.url === `file://${process.argv[1]}`) {
  const successRate = main();
  process.exit(successRate === 100 ? 0 : 1);
}

export { main, validateMigrationFiles, validateScripts, validateEnhancedVectorSearch };